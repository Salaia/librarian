package puma.hope.librarian.event.model;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.Past;
import jakarta.validation.constraints.Pattern;
import lombok.*;
import lombok.experimental.FieldDefaults;

import java.time.LocalDate;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(name = "users", schema = "librarian")
public class User {

    @Id
    @Column(name = "user_id")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Schema(name = "id", example = "1", description = "User ID, generated by the DataBase")
    Long id;

    @Email(message = "Invalid email!")
    @Schema(name = "email", example = "nickname@mail.com")
    String email;

    @Pattern(regexp = "[^ ]*", message = "There must be no space symbols in login!")
    @NotEmpty(message = "Login may not be empty!")
    @Schema(name = "login", example = "YourNickname", description = "Login may not be empty and may not contain space symbols")
    String login;

    // Была мысль написать рандомайзер, предлагающий варианты логина
    // Это дело бэка, а не фронта, потому что проверять бы на уникальность,
    // прежде чем предлагать юзеру
    @NotEmpty(message = "Name may not be empty!")
    @Schema(name = "name", example = "Firstname Lastname", description = "Displayed name. May not be empty")
    String name;

    @Past(message = "Birth date may not be in future!")
    @Schema(name = "birthday", example = "1946-08-20", description = "Birthday may not be in future. Date format: YYYY-MM-DD")
    LocalDate birthday;

    //final Set<Long> friendsIds = new HashSet<>();
    // заменила с переходом на JPA на новый класс Friendship
}